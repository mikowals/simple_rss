import React from 'react';
import {cleanup, MockedProvider} from '@apollo/client/testing';
import { InMemoryCache } from '@apollo/client';
import renderer, {act} from 'react-test-renderer';
//import { fireEvent } from '@testing-library/react';
import { Simulate } from 'react-dom/test-utils';
import {FeedsPage, AddFeed} from '../feeds';
import { FEEDS_QUERY } from '../../api/query';
import { REMOVE_FEED, ADD_FEED } from '../../api/mutation';
import "babel-polyfill";
import wait from 'waait';

const feed1 = {
  _id: '1',
  title: 'a publisher',
  url: 'http://blah.blah.com',
  date: (new Date()).getTime(),
  count: 3
};

const feed2 = {
  _id: '2',
  title: "another publisher",
  url: "http://more.blah.com",
  date: (new Date()).getTime() - 2000,
  count: 4
}

// For insertion tests the __typename fields allow apollo to generate cache ids.
const feed3 = {
  _id: '3',
  title: 'some guy',
  url: 'http://blah_blah.com',
  date: (new Date()).getTime(),
  count: 5,
  __typename: "Feed",
};

// This object is to be inserted.
// Its _id of '4' matches the return of _makeNewID mock in /.meteorMocks/index.js.
const feed4 = {
  _id: '4',
  title: "a woman",
  url: "http://again_with_the_blah.com",
  date: (new Date()).getTime() - 2000,
  count: 6,
  __typename: "Feed",
}

afterEach(() => cleanup);

it('renders without error', async () => {
  const mocks = [
    {
      request: {
        query: FEEDS_QUERY,
        variables: { userId: 'nullUser'}
      },
      result: {
        data: {
          feeds: [feed1, feed2]
        }
      },
    },
  ];
  const component = renderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <FeedsPage />
    </MockedProvider>,
  );

  await act(wait);
  const tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});

it('can remove a feed', async () => {
  let mutationCalled = false;
  const mocks = [
    {
      request: {
        query: FEEDS_QUERY,
        variables: { userId: 'nullUser'}
      },
      result: {
        data: {
          feeds: [feed1, feed2]
        }
      },
    },{
      // _id: '1' matches _id of list item clicked for removal.
      request: {
        query: REMOVE_FEED,
        variables: { id: '1'}
      },
      result: () => {
        mutationCalled = true;
        return {
          data: {
            removeFeed: {_id: "1"}
          }
        }
      },
    },{
      request: {
        query: FEEDS_QUERY,
        variables: { userId: 'nullUser'}
      },
      result: {
        data: {
          feeds: [feed2]
        }
      },
    },
  ];
  const component = renderer.create(
    <MockedProvider mocks={mocks} addTypename={false}>
      <FeedsPage />
    </MockedProvider>,
  );

  await act(wait);
  const listItems = component.root.findAllByType('li');
  expect(listItems).toHaveLength(2)

  act(listItems[0].findByType('i').parent.props.onClick);
  await act(wait);
  expect(mutationCalled).toBe(true);
  const listItems2 = component.root.findAllByType('li');
  expect(listItems2).toHaveLength(1)
  expect(listItems2[0].parent.props._id).toBe('2');
  await act(wait);
});

it('errors without input text', async () => {
  jest.spyOn(window, 'alert').mockImplementation(() => {});
  const component = renderer.create(
    <MockedProvider mocks={[]} addTypename={true}>
      <AddFeed />
    </MockedProvider>,
  );

  const form = component.root.findByType('form');
  act(() => form.props.onSubmit({
    preventDefault: () => {},
    stopPropagation: () => {}
  }));
  await act(wait);
  expect(window.alert).toBeCalledWith("URL can not be empty");
});

it('can add a feed', async () => {
  let mutationCalled = false;
  const mocks = [
    {
      request: {
        query: FEEDS_QUERY,
        variables: { userId: 'nullUser'}
      },
      result: {
        data: {
          feeds: [feed3]
        }
      },
    },{
      // _id: '4' matches the variables generated by mocked _makeNewID.
      request: {
        query: ADD_FEED,
        variables: { _id: '4', url:"http://another.com"}
      },
      result: () => {
        mutationCalled = true;
        return {
          data: {
            __typename: "mutation",
            addFeed: feed4,
          }
        }
      },
    },{
      request: {
        query: FEEDS_QUERY,
        variables: { userId: 'nullUser'}
      },
      result: {
        data: {
          feeds: [feed3, feed4]
        }
      },
    },
  ];
  const component = renderer.create(
    <MockedProvider mocks={mocks} addTypename={true}>
      <FeedsPage />
    </MockedProvider>,
  );

  await act(wait);
  const listItems = component.root.findAllByType('li');
  expect(listItems).toHaveLength(1)

  const input = component.root.findByType('input');
  act(() => input.props.onChange({target: {value: "http://another.com"}}));
  expect(input.props.value).toBe("http://another.com");
  const button = component.root.findByType('form').findByType('a');
  act(() => {
    button.props.onClick({
      preventDefault: () => {},
      stopPropagation: () => {}
    })
  });
  expect(input.props.value).toBe("");
  await act(wait);

  expect(mutationCalled).toBe(true);
  const listItemsAfter = component.root.findAllByType('li');
  expect(listItemsAfter).toHaveLength(2)
});

// This needs tests for failing cases.
// Add duplicate url.]
